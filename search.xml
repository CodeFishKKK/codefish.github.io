<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>南宁周赛（10.22）</title>
      <link href="/2022/10/22/%E5%8D%97%E5%AE%81%E5%91%A8%E8%B5%9B%EF%BC%8810.22%EF%BC%89/"/>
      <url>/2022/10/22/%E5%8D%97%E5%AE%81%E5%91%A8%E8%B5%9B%EF%BC%8810.22%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>流浪的兔子先生在蓝星遇见了很多朋友，每次兔子先生到朋友家做客，朋友们都会给兔子先生做一大桌子好吃的。</p><p>由于蓝星的朋友们都非常喜欢质数，因此饭桌上盘子背后都有一个质数作为标识。</p><p>朋友们每次都会在饭后告诉兔子先生，这顿饭所有盘子背后数字的乘积。</p><p>笨笨的兔子先生想知道哪些盘子是他所有朋友都共同拥有的，你能帮帮他嘛？QAQ</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行输入一个整数 n<em>n</em> ,代表兔子先生的朋友数量。</p><p>第二行输入 n<em>n</em> 个整数 a_i<em>a**i</em>，代表朋友们告诉兔子先生的这顿饭的盘子标识的乘积。</p><p>1 &lt;&#x3D; n &lt;&#x3D; 1e6, 2 &lt;&#x3D; $ai$ &lt;&#x3D; 1e12</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>第一行输出共同盘子的个数，第二行从小到大输出盘子的标识。</p><h3 id="样例1"><a href="#样例1" class="headerlink" title="样例1"></a>样例1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入样例：</span><br><span class="line">4</span><br><span class="line">4 4 4 12</span><br><span class="line">输出样例：</span><br><span class="line">2</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure><hr><p>分析：</p><p>读懂题目意思是每个人吃一些编号的盘子，编号都是质数，以前学数论的时候知道每个数都能被拆成指数的乘积，但是人数n已经到了10的六次方，每个都拆的话复杂度已经远超1e8必定会T，又因为题目只要公共的盘子，二最大公约数的所有质因子就是所有公共盘子的编号，所以只需要求最大公约数的所有质因子即可！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x...) cerr <span class="string">&lt;&lt; (#x) &lt;&lt;&quot; -&gt;</span> <span class="string">&quot;, err(x)</span></span></span><br><span class="line"><span class="string"><span class="meta">#define all(x) (x).begin(), (x).end()</span></span></span><br><span class="line"><span class="string"><span class="meta">#define sz(x) ((int)(x).size())</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">#define fi first</span></span></span><br><span class="line"><span class="string"><span class="meta">#define se second</span></span></span><br><span class="line"><span class="string"><span class="meta">#define endl &#x27;\n&#x27;</span></span></span><br><span class="line"><span class="string"><span class="meta">#define int long long</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">void err() &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">cerr &lt;&lt; &#x27;\n&#x27;;</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">template&lt;class T, class... Ts&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">void err(const T &amp;A, const Ts &amp;... other) &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">cerr &lt;&lt; (A) &lt;&lt; &#x27; &#x27;;</span></span></span><br><span class="line"><span class="string"><span class="meta">err(other...);</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">using PII = pair&lt;int, int&gt;;</span></span></span><br><span class="line"><span class="string"><span class="meta">using ll = long long;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">const int N = 100000010, INF = 0x3f3f3f3f;</span></span></span><br><span class="line"><span class="string"><span class="meta">const int mod = 998244353;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">int n, now_gcd, end_num;</span></span></span><br><span class="line"><span class="string"><span class="meta">vector&lt;int&gt; cnt;</span></span></span><br><span class="line"><span class="string"><span class="meta">int num[N];</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">int gcd(int a, int b)&#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">return b ? gcd(b, a % b) : a;</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">void divide(int x)&#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">    for(int i = 2; i &lt;= x/i; i ++ )</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">        if(x % i == 0)&#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">            int d = 0;</span></span></span><br><span class="line"><span class="string"><span class="meta">            while(x % i == 0)&#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">            x /= i;</span></span></span><br><span class="line"><span class="string"><span class="meta">            d ++;</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">            num[i] += d;</span></span></span><br><span class="line"><span class="string"><span class="meta">            cnt.push_back(i);</span></span></span><br><span class="line"><span class="string"><span class="meta">            end_num += d;</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">        </span></span></span><br><span class="line"><span class="string"><span class="meta">        </span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    </span></span></span><br><span class="line"><span class="string"><span class="meta">    if(x &gt; 1) &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">    num[x] += 1;</span></span></span><br><span class="line"><span class="string"><span class="meta">    cnt.push_back(x);</span></span></span><br><span class="line"><span class="string"><span class="meta">    end_num ++;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    puts(&quot;</span><span class="string">&quot;);</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">void solve() &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">int x, t;</span></span></span><br><span class="line"><span class="string"><span class="meta">cin &gt;&gt; n &gt;&gt; t;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">now_gcd = t;</span></span></span><br><span class="line"><span class="string"><span class="meta">for(int i = 1; i &lt; n; i ++ )&#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">cin &gt;&gt; x;</span></span></span><br><span class="line"><span class="string"><span class="meta">now_gcd = gcd(now_gcd, x);</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">if(now_gcd)&#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">divide(now_gcd);</span></span></span><br><span class="line"><span class="string"><span class="meta">sort(cnt.begin(), cnt.end());</span></span></span><br><span class="line"><span class="string"><span class="meta">cnt.erase((cnt.begin(), cnt.end()), cnt.end());</span></span></span><br><span class="line"><span class="string"><span class="meta">cout &lt;&lt; end_num &lt;&lt; endl;</span></span></span><br><span class="line"><span class="string"><span class="meta">for(auto t : cnt)&#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">for(int i = 0; i &lt; num[t]; i ++ ) cout &lt;&lt; t &lt;&lt; &quot;</span> <span class="string">&quot;;</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125; else &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">puts(&quot;</span>0<span class="string">&quot;);</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">signed main() &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">ios::sync_with_stdio(false);</span></span></span><br><span class="line"><span class="string"><span class="meta">cin.tie(nullptr);</span></span></span><br><span class="line"><span class="string"><span class="meta">int ___ = 1;</span></span></span><br><span class="line"><span class="string"><span class="meta">// cin &gt;&gt; ___;</span></span></span><br><span class="line"><span class="string"><span class="meta">for (int i = 1; i &lt;= ___; i ++) solve();</span></span></span><br><span class="line"><span class="string"><span class="meta">return 0;</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;</span></span></span><br></pre></td></tr></table></figure><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h2><p>自从2022年10月21日cm毁灭宇宙之后，蓝星又进入了新一轮演化。某一天，蓝星星主突然出现一段往日的回忆，想起了往日的恋人：月星。众所周知，四边形代表爱情，蓝星为了重新追求月星，准备计算出宇宙中有多少种四边形星座。</p><p>tip:四边形星座中，存在一个与其它星座不同的星星，即为不同的四边形星座</p><h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>第一行，你将得到一个整 <code>N</code>，表示星星的数量。</p><p>接下来每行两个数<code>X</code>，<code>Y</code>表示星星所在的坐标。</p><p>1 &lt;&#x3D; N &lt;&#x3D; 100, $-10^6$ &lt;&#x3D; X,Y &lt;&#x3D; $10^6$</p><h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>输出一个整数，表示有多少种四边形星座</p><h3 id="样例1-1"><a href="#样例1-1" class="headerlink" title="样例1"></a>样例1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">10 10</span><br><span class="line">10 20</span><br><span class="line">20 20</span><br><span class="line">20 10</span><br><span class="line">25 15</span><br></pre></td></tr></table></figure><hr><p>分析：</p><blockquote><p>题目中坐标数n最多100个暴力的话复杂度为1e6可行，<code>判断四个坐标是否在能构成四边形只需要判断三点是否共线</code>，即可，要是存坐标去重的话复杂度会上升到4^4^1e6,就会极限的t掉了QAQ</p></blockquote><p>判断是否共线代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool cal(pair&lt;ll, ll&gt; x, pair&lt;ll, ll&gt; y, pair&lt;ll, ll&gt; z) &#123;</span><br><span class="line">return (z.second - x.second) * (y.first - x.first) - (y.second - x.second) * (z.first - x.first) == 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>原理：求斜率本来是除的，会出现小数还会有误差处理起来比较麻烦，但是这里判断共线是判断斜率是否相等，所以交叉相乘分母就成了上面的式子</p></blockquote><p>AC代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x...) cerr <span class="string">&lt;&lt; (#x) &lt;&lt;&quot; -&gt;</span> <span class="string">&quot;, err(x)</span></span></span><br><span class="line"><span class="string"><span class="meta">#define all(x) (x).begin(), (x).end()</span></span></span><br><span class="line"><span class="string"><span class="meta">#define sz(x) ((int)(x).size())</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">#define fi first</span></span></span><br><span class="line"><span class="string"><span class="meta">#define se second</span></span></span><br><span class="line"><span class="string"><span class="meta">#define endl &#x27;\n&#x27;</span></span></span><br><span class="line"><span class="string"><span class="meta">#define int long long</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">void err() &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">cerr &lt;&lt; &#x27;\n&#x27;;</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">template&lt;class T, class... Ts&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">void err(const T &amp;A, const Ts &amp;... other) &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">cerr &lt;&lt; (A) &lt;&lt; &#x27; &#x27;;</span></span></span><br><span class="line"><span class="string"><span class="meta">err(other...);</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">using PII = pair&lt;int, int&gt;;</span></span></span><br><span class="line"><span class="string"><span class="meta">using ll = long long;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">const int N = 2e6 + 10, INF = 0x3f3f3f3f;</span></span></span><br><span class="line"><span class="string"><span class="meta">const int mod = 998244353;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">bool cal(pair&lt;ll, ll&gt; x, pair&lt;ll, ll&gt; y, pair&lt;ll, ll&gt; z) &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">return (z.second - x.second) * (y.first - x.first) - (y.second - x.second) * (z.first - x.first) == 0;</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">void solve() &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">int n;</span></span></span><br><span class="line"><span class="string"><span class="meta">cin &gt;&gt; n;</span></span></span><br><span class="line"><span class="string"><span class="meta">vector&lt;pair&lt;ll, ll&gt;&gt; point(n);</span></span></span><br><span class="line"><span class="string"><span class="meta">for(int i = 0; i &lt; n; i++) cin &gt;&gt; point[i].first &gt;&gt; point[i].second;</span></span></span><br><span class="line"><span class="string"><span class="meta">ll res = 0;</span></span></span><br><span class="line"><span class="string"><span class="meta">for(int i = 0; i &lt; n; i++)</span></span></span><br><span class="line"><span class="string"><span class="meta">for(int j = i + 1; j &lt; n; j++)</span></span></span><br><span class="line"><span class="string"><span class="meta">for(int z = j + 1; z &lt; n; z++)</span></span></span><br><span class="line"><span class="string"><span class="meta">for(int x = z + 1; x &lt; n; x++) &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">if(cal(point[i], point[j], point[z]) || cal(point[i], point[j], point[x]) || cal(point[j], point[z], point[x]) || cal(point[i], point[z], point[x])) continue;</span></span></span><br><span class="line"><span class="string"><span class="meta">res++;</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">cout &lt;&lt; res &lt;&lt; endl;;</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">signed main() &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">ios::sync_with_stdio(false);</span></span></span><br><span class="line"><span class="string"><span class="meta">cin.tie(nullptr);</span></span></span><br><span class="line"><span class="string"><span class="meta">int ___ = 1;</span></span></span><br><span class="line"><span class="string"><span class="meta">// cin &gt;&gt; ___;</span></span></span><br><span class="line"><span class="string"><span class="meta">for (int i = 1; i &lt;= ___; i ++) solve();</span></span></span><br><span class="line"><span class="string"><span class="meta">return 0;</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> contest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea常用快捷键</title>
      <link href="/2022/10/16/idea%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2022/10/16/idea%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="idea常用的快捷键"><a href="#idea常用的快捷键" class="headerlink" title="idea常用的快捷键"></a>idea常用的快捷键</h1><table><thead><tr><th>快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td>Ctrl + F</td><td align="left">在当前文件进行文本查找</td></tr><tr><td>Ctrl + R</td><td align="left">在当前文件进行文本替换</td></tr><tr><td>Ctrl + D</td><td align="left">复制选择内容，并把复制内容插入光标位置下面</td></tr><tr><td>Ctrl + W</td><td align="left">递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围</td></tr><tr><td>Shift + F10</td><td align="left">等效于点击工具栏的 <code>Run</code> 按钮</td></tr><tr><td>Ctrl + Alt + L</td><td align="left">格式化代码，可以对当前文件和整个包目录使用</td></tr><tr><td>Ctrl + Shift + Z</td><td align="left">取消撤销</td></tr><tr><td>Ctrl + Shift + F</td><td align="left">根据输入内容查找整个项目 或 指定目录内文件</td></tr><tr><td>Ctrl + Shift + &#x2F;</td><td align="left">代码块注释</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 工程项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工程项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java工具语法</title>
      <link href="/2022/10/16/java%E5%B7%A5%E5%85%B7%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/10/16/java%E5%B7%A5%E5%85%B7%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Java工具的语法"><a href="#Java工具的语法" class="headerlink" title="Java工具的语法"></a>Java工具的语法</h1><h2 id="1-输入-x2F-输出"><a href="#1-输入-x2F-输出" class="headerlink" title="1.输入&#x2F;输出"></a>1.输入&#x2F;输出</h2><h3 id="快速输入"><a href="#快速输入" class="headerlink" title="快速输入"></a>快速输入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> br.readLine();</span><br></pre></td></tr></table></figure><h3 id="快速输出"><a href="#快速输出" class="headerlink" title="快速输出"></a>快速输出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">bw.write(str);</span><br><span class="line">bw.flush();</span><br></pre></td></tr></table></figure><h2 id="2-栈的操作"><a href="#2-栈的操作" class="headerlink" title="2.栈的操作"></a>2.栈的操作</h2><table><thead><tr><th>方法</th><th>类型</th><th>方法描述</th></tr></thead><tbody><tr><td>empty()</td><td>boolean</td><td>测试堆栈是否为空</td></tr><tr><td>push(E item)</td><td>E</td><td>把项压入堆栈顶部</td></tr><tr><td>pop()</td><td>E</td><td>移除堆栈顶部的对象，并作为此函数的值返回该对象</td></tr><tr><td>peek()</td><td>E</td><td>查看堆栈顶部的对象，但不从堆栈中移除它</td></tr><tr><td>search(Object o)</td><td>int</td><td>返回对象再堆栈中的位置，以1为基数</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取stack长度</span></span><br><span class="line">size()</span><br><span class="line"><span class="comment">//下标处添加</span></span><br><span class="line">add(<span class="type">int</span> index, E element)</span><br><span class="line"><span class="comment">//添加集合</span></span><br><span class="line">addAll(Collection&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt; c)</span><br><span class="line"><span class="comment">//移除对象</span></span><br><span class="line">remove(Object obj)</span><br><span class="line"><span class="comment">//根据下标移除对象</span></span><br><span class="line">remove(<span class="type">int</span> index)</span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">clear()</span><br></pre></td></tr></table></figure><h2 id="3-写算法题标准模板"><a href="#3-写算法题标准模板" class="headerlink" title="3.写算法题标准模板"></a>3.写算法题标准模板</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">QuickRead</span> <span class="variable">qr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QuickRead</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">T</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">//        T = qr.nextInt();</span></span><br><span class="line">        <span class="keyword">for</span> (; T &gt; <span class="number">0</span>; T --) solve();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123; <span class="comment">// Let&#x27;s Go</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">QuickRead</span> &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">StringTokenizer</span> <span class="variable">tokenizer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTokenizer</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">while</span> (tokenizer == <span class="literal">null</span> || !tokenizer.hasMoreElements()) &#123;</span><br><span class="line">                tokenizer = <span class="keyword">new</span> <span class="title class_">StringTokenizer</span>(reader.readLine());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">next</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasNext()) <span class="keyword">return</span> tokenizer.nextToken();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">nextLine</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">            <span class="keyword">return</span> reader.readLine();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">nextChar</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">            <span class="keyword">return</span> next().charAt(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextInt</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.parseInt(next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextLong</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">return</span> Long.parseLong(next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">nextDouble</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">return</span> Double.parseDouble(next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> BigInteger <span class="title function_">nextBigInteger</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> BigDecimal <span class="title function_">nextBigDecimal</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数的图像（中）</title>
      <link href="/2022/09/12/%E5%87%BD%E6%95%B0%E7%9A%84%E5%9B%BE%E5%83%8F%EF%BC%88%E4%B8%AD%EF%BC%89/"/>
      <url>/2022/09/12/%E5%87%BD%E6%95%B0%E7%9A%84%E5%9B%BE%E5%83%8F%EF%BC%88%E4%B8%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<ul><li><p>三角函数tip：</p><p><img src="https://laukun-1313741272.cos.ap-guangzhou.myqcloud.com/Blog/7D75B82FCDED707D17E05299B27E9889.png"></p><blockquote><p>带绝对值的函数优先考虑函数图像</p></blockquote></li><li><p>证明f(x)&#x3D;常数c</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.求导f‘(x)=0 </span><br><span class="line"></span><br><span class="line">2.f(x0)=c</span><br></pre></td></tr></table></figure></li></ul><p>tip:画图象先算两端点再判断增减</p><ul><li><p>取整函数 y&#x3D;[x], 不超过x的最大整数</p><p>定义域：R</p><p>值域：Z</p></li></ul><p><img src="https://laukun-1313741272.cos.ap-guangzhou.myqcloud.com/Blog/V(ENR56R@%7B%7DWPE($KMHAG~H.png"></p><ul><li><p>Tip:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Tip: X~n+1~ = sinX~n~ &lt; X~n~ (X~n~&gt;0)</span><br><span class="line">=&gt; &#123;X~n~&#125; 单调递减</span><br></pre></td></tr></table></figure><blockquote><p>由数列的函数表达式判断增减性方法:</p><ul><li>10个常见不等式</li><li>求导</li></ul></blockquote></li><li><p>Tip: 不等式敏感：e^x^ &gt;&#x3D; x + 1</p><p>敏感变量：e^x^，  x</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 高数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初试线段树</title>
      <link href="/2021/06/18/%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B4%E6%95%B0%E9%97%AE%E9%A2%98-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2021/06/18/%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B4%E6%95%B0%E9%97%AE%E9%A2%98-%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个长度为 N 的数列 A，以及 M 条指令，每条指令可能是以下两种之一：</p><ol><li><code>C l r d</code>，表示把 A[l],A[l+1],…,A[r]都加上 d。</li><li><code>Q l r</code>，表示询问数列中第 l∼r个数的和。</li></ol><p>对于每个询问，输出一个整数表示答案输入格式</p><p>第一行两个整数 N,M。</p><p>第二行 NN 个整数 A[i]。</p><p>接下来 M 行表示 M条指令，每条指令的格式如题目描述所示。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每个询问，输出一个整数表示答案。</p><p>每个答案占一行。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N,M≤$10^5$<br>|d|≤10000<br>|A[i]|≤ $10^9$ </p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">10 5</span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line">Q 4 4</span><br><span class="line">Q 1 10</span><br><span class="line">Q 2 4</span><br><span class="line">C 3 6 3</span><br><span class="line">Q 2 4</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">55</span><br><span class="line">9</span><br><span class="line">15</span><br></pre></td></tr></table></figure><hr><p>分析：</p><p>题目涉及区间修改和区间查询，分析数据范围不能暴力，符合线段树的用法；<br>一旦涉及区间修改线段树就要用到懒标记；</p><h2 id="问：什么是懒标记，有什么作用？"><a href="#问：什么是懒标记，有什么作用？" class="headerlink" title="问：什么是懒标记，有什么作用？"></a>问：什么是懒标记，有什么作用？</h2><blockquote><p>懒标记就是用来记录要要对某一区间进行的修改，tr[u].add就是u区间的懒标记，它标志着u区间的每一个点都要加上add，但是先不直接加上去，否则复杂度就会大大提高，就体现不出线段树的优势所在，要查询或者修改带有懒标记的点的儿子时，懒标记就会使用对用pushdown操作把要修改的操作分配下去</p></blockquote><h2 id="问：什么时候进行pushdown操作？为什么要进行pushdown操作？"><a href="#问：什么时候进行pushdown操作？为什么要进行pushdown操作？" class="headerlink" title="问：什么时候进行pushdown操作？为什么要进行pushdown操作？"></a>问：什么时候进行pushdown操作？为什么要进行pushdown操作？</h2><blockquote><p>带懒标记节点就像是父亲，add是爷爷发给孙子的压岁钱，当需要计算儿子压岁钱（查询到带懒标记的儿子时）或者又有新的一笔钱要给孙子时（修改操作），父亲就需要先把这笔钱分发给儿子才能进行下一步操作<br>查询的到下面儿子的时候需要算上本属于儿子的懒标记的值，所以query时需要进行pushdown操作无容置疑<br>修改操作时懒标记时一个区间的操作，要改变就需要带着一个区间一块改变，如果一个新的修改执行pushdown没有执行，就是本来因该给儿子的还没有给。回溯时pushup操作就会拿着错误的值去计算父节点，导致结果出错！</p></blockquote><p>话不多说，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, w[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    LL sum, add;</span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;root = tr[u], &amp;left = tr[u &lt;&lt; <span class="number">1</span>], &amp;right = tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(root.add)&#123;</span><br><span class="line">        left.add += root.add, left.sum += (left.r - left.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        right.add += root.add, right.sum += (right.r - right.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        root.add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    tr[u].sum = (LL)tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) tr[u] = &#123;l, r, w[l], <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        tr[u] = &#123;l, r&#125;;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)&#123; </span><br><span class="line"><span class="comment">//区间修改如果找到完全在要修改的区间内的子区间，就直接加到懒标记上面，就代表着这个区间的每一个值都要这样修改</span></span><br><span class="line">         tr[u].sum += (LL)(tr[u].r - tr[u].l + <span class="number">1</span>) * v;</span><br><span class="line">         tr[u].add += (LL)v;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="built_in">pushdown</span>(u); <span class="comment">//此处分裂，修改到了可能带懒标记的儿子，要进行pushdown操作</span></span><br><span class="line">         <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, v);</span><br><span class="line">         <span class="keyword">if</span>(r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, v);</span><br><span class="line">         <span class="built_in">pushup</span>(u); <span class="comment">//回溯用修改后的儿子更新父亲的区间和</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u);  <span class="comment">//查询到了可能带懒标记的父亲的儿子</span></span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        LL sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= mid) sum = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; mid) sum += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;w[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    LL d;</span><br><span class="line">    <span class="keyword">while</span>(m -- )&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, &amp;op, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">if</span>(*op == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, l, r));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;d);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, l, r, d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP字符串</title>
      <link href="/2021/05/18/KMP%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2021/05/18/KMP%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是KMP算法及一些基本概念"><a href="#一、什么是KMP算法及一些基本概念" class="headerlink" title="一、什么是KMP算法及一些基本概念"></a>一、什么是KMP算法及一些基本概念</h2><p>首先，什么是KMP算法。这是一个字符串匹配算法，对暴力的那种一一比对的方法进行了优化，使时间复杂度大大降低（我不会算时间复杂度。。。，目前也只能这么理解，还有KMP是取的三个发明人的名字首字母组成的名字）。</p><p> 然后是一些基本概念：</p><blockquote><p>1、s[ ]是模式串，即比较长的字符串。<br>2、p[ ]是模板串，即比较短的字符串。（这样可能不严谨。。。）<br>3、“非平凡前缀”：指除了最后一个字符以外，一个字符串的全部头部组合。<br>4、“非平凡后缀”：指除了第一个字符以外，一个字符串的全部尾部组合。（后面会有例子，均简称为前&#x2F;后缀）<br>5、“部分匹配值”：前缀和后缀的最长共有元素的长度。<br>6、next[ ]是“部分匹配值表”，即next数组，它存储的是每一个下标对应的“部分匹配值”，是KMP算法的核心。（后面作详细讲解）。</p></blockquote><p>核心思想 ： 在每次失配时，不是把p串往后移一位，而是把p串往后移动至下一次可以和前面部分匹配的位置，这样就可以跳过大多数的失配步骤。而每次p串移动的步数就是通过查找next[ ]数组确定的。</p><h3 id="二、next数组的含义及手动模拟（具体求法和代码在后面）"><a href="#二、next数组的含义及手动模拟（具体求法和代码在后面）" class="headerlink" title="二、next数组的含义及手动模拟（具体求法和代码在后面）"></a>二、next数组的含义及手动模拟（具体求法和代码在后面）</h3><p> 然后来说明一下next数组的含义：对next[ j ] ，是p[ 1, j ]串中前缀和后缀相同的最大长度（部分匹配值），即 p[ 1, next[ j ] ] &#x3D; p[ j - next[ j ] + 1, j ]。</p><p><img src="https://cdn.acwing.com/media/article/image/2020/06/12/31041_6f934f82ac-next%E4%BE%8B%E5%AD%90.PNG"></p><hr><p>手动模拟求next数组：</p><p>对 p &#x3D; “abcab”</p><p><img src="https://laukun-1313741272.cos.ap-guangzhou.myqcloud.com/Blog/kmp.png"></p><p>对next[ 1 ] ：前缀 &#x3D; 空集—————后缀 &#x3D; 空集—————next[ 1 ] &#x3D; 0;</p><p>对next[ 2 ] ：前缀 &#x3D; { a }—————后缀 &#x3D; { b }—————next[ 2 ] &#x3D; 0;</p><p>对next[ 3 ] ：前缀 &#x3D; { a , ab }—————后缀 &#x3D; { c , bc}—————next[ 3 ] &#x3D; 0;</p><p>对next[ 4 ] ：前缀 &#x3D; { a , ab , abc }—————后缀 &#x3D; { a . ca , bca }—————next[ 4 ] &#x3D; 1;</p><p>对next[ 5 ] ：前缀 &#x3D; { a , ab , abc , abca }————后缀 &#x3D; { b , ab , cab , bcab}————next[ 5 ] &#x3D; 2;</p><hr><h3 id="三、匹配思路和实现代码"><a href="#三、匹配思路和实现代码" class="headerlink" title="三、匹配思路和实现代码"></a>三、匹配思路和实现代码</h3><p>KMP主要分两步：求next数组、匹配字符串。个人觉得匹配操作容易懂一些，疑惑我一整天的是求next数组的思想。所以先把匹配字符串讲一下。</p><p> s串 和 p串都是从1开始的。i 从1开始，j 从0开始，每次s[ i ] 和p[ j + 1 ]比较</p><p>其中1串为[ 1, next[ j ] ]，3串为[ j - next[ j ] + 1 , j ]。由匹配可知 1串等于3串，3串等于2串。所以直接移动p串使1到3的位置即可。这个操作可由j &#x3D; next[ j ]直接完成。 如此往复下去，当 j &#x3D;&#x3D; m时匹配成功。</p><hr><h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j &amp;&amp; s[i] != p[j+<span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="comment">//如果j有对应p串的元素， 且s[i] != p[j+1], 则失配， 移动p串</span></span><br><span class="line">    <span class="comment">//用while是由于移动后可能仍然失配，所以要继续移动直到匹配或整个p串移到后面（j = 0)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s[i] == p[j+<span class="number">1</span>]) j++;</span><br><span class="line">    <span class="comment">//当前元素匹配，j移向p串下一位</span></span><br><span class="line">    <span class="keyword">if</span>(j == m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//匹配成功，进行相关操作</span></span><br><span class="line">        j = next[j];  <span class="comment">//继续匹配下一个子串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、求next数组的思路和实现代码"><a href="#四、求next数组的思路和实现代码" class="headerlink" title="四、求next数组的思路和实现代码"></a>四、求next数组的思路和实现代码</h3><p>next数组的求法是通过模板串自己与自己进行匹配操作得出来的（代码和匹配操作几乎一样）。</p><h3 id="代码如下：-1"><a href="#代码如下：-1" class="headerlink" title="代码如下："></a>代码如下：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j &amp;&amp; p[i] != p[j+<span class="number">1</span>]) j = next[j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p[i] == p[j+<span class="number">1</span>]) j++;</span><br><span class="line"></span><br><span class="line">    next[i] = j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码和匹配操作的代码几乎一样，关键在于每次移动 i 前，将 i 前面已经匹配的长度记录到next数组中。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">10010</span>; <span class="comment">//N为模式串长度，M匹配串长度</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> ne[M]; <span class="comment">//next[]数组，避免和头文件next冲突</span></span><br><span class="line"><span class="type">char</span> s[N], p[M];  <span class="comment">//s为模式串， p为匹配串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s+<span class="number">1</span> &gt;&gt; m &gt;&gt; p+<span class="number">1</span>;  <span class="comment">//下标从1开始</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//求next[]数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; p[i] != p[j+<span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(p[i] == p[j+<span class="number">1</span>]) j++;</span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//匹配操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; s[i] != p[j+<span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(s[i] == p[j+<span class="number">1</span>]) j++;</span><br><span class="line">        <span class="keyword">if</span>(j == m)  <span class="comment">//满足匹配条件，打印开头下标, 从0开始</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//匹配完成后的具体操作</span></span><br><span class="line">            <span class="comment">//如：输出以0开始的匹配子串的首字母下标</span></span><br><span class="line">            <span class="comment">//printf(&quot;%d &quot;, i - m); (若从1开始，加1)</span></span><br><span class="line">            j = ne[j];            <span class="comment">//再次继续匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>万能神器-二分法</title>
      <link href="/2021/05/12/%E4%BA%8C%E5%88%86/"/>
      <url>/2021/05/12/%E4%BA%8C%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h3 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h3><p>给定一个按照升序排列的长度为n的整数数组，以及 q 个查询。<br>对于每个查询，返回一个元素k的起始位置和终止位置（位置从0开始计数）。<br>如果数组中不存在该元素，则返回“-1 -1”。<br>输入格式<br>第一行包含整数n和q，表示数组长度和询问个数。<br>第二行包含n个整数（均在1~10000范围内），表示完整数组。<br>接下来q行，每行包含一个整数k，表示一个询问元素。<br>输出格式<br>共q行，每行包含两个整数，表示所求元素的起始位置和终止位置。<br>如果数组中不存在该元素，则返回“-1 -1”。<br>数据范围<br>1≤n≤100000<br>1≤n≤100000</p><p>1≤q≤10000<br>1≤q≤10000</p><p>1≤k≤10000<br>1≤k≤10000</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入样例：</span><br><span class="line">6 3</span><br><span class="line">1 2 2 3 3 4</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">输出样例：</span><br><span class="line">3 4</span><br><span class="line">5 5</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure><hr><p>分析：</p><p>本题是练习二分很好的一道题目，二分程序虽然简单，但是如果写之前不考虑好想要查找的是什么，十有八九会是死循环或者查找错误，就算侥幸写对了也只是运气好而已。用二分去查找元素要求数组的有序性或者拥有类似于有序的性质，对本题而言，一个包含重复元素的有序序列，要求输出某元素出现的起始位置和终止位置，翻译一下就是：在数组中查找某元素，找不到就输出-1，找到了就输出不小于该元素的最小位置和不大于该元素的最大位置。所以，需要写两个二分，一个需要找到&gt;&#x3D;x的第一个数，另一个需要找到&lt;&#x3D;x的最后一个数。查找不小于x的第一个位置，较为简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &lt; x)  l = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>    r = mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当a[mid]小于x时，令l &#x3D; mid + 1，mid及其左边的位置被排除了，可能出现解的位置是mid + 1及其后面的位置；当a[mid] &gt;&#x3D; x时，说明mid及其左边可能含有值为x的元素；当查找结束时，l与r相遇，l所在元素若是x则一定是x出现最小位置，因为l左边的元素必然都小于x。查找不大于x的最后一个位置，便不容易了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> l1 = l, r1 = n;</span><br><span class="line"><span class="keyword">while</span> (l1 + <span class="number">1</span> &lt; r1) &#123;</span><br><span class="line">    <span class="type">int</span> mid = l1 + r1 &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &lt;= x)  l1 = mid;</span><br><span class="line">    <span class="keyword">else</span>    r1 = mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要查找不大于x的最后一个位置，当a[mid] &lt;&#x3D; x时，待查找元素只可能在mid及其后面，所以l &#x3D; mid；当a[mid] &gt; x时，待查找元素只会在mid左边，令r &#x3D; mid。<br>为什么不令r &#x3D; mid - 1呢？因为如果按照上一个二分的写法，循环判断条件还是l &lt; r,当只有两个元素比如2 2时，l指向第一个元素，r指向第二个元素，mid指向第一个元素，a[mid] &lt;&#x3D; x，l &#x3D; mid还是指向第一个元素，指针不移动了，陷入死循环了，此刻l + 1 &#x3D;&#x3D; r，未能退出循环。<br>那么直接把循环判断条件改成l + 1 &lt; r呢？此时一旦只有两个元素，l和r差1，循环便不再执行，查找错误。<br>所以这里出现了二分的典型错误，l &#x3D;&#x3D; r作为循环终止条件，会出现死循环，l + 1 &#x3D;&#x3D; r作为循环终止条件，会出现查找错误。<br>问题如何解决，一种方法就是将查找的区间设置为左闭右开，比如待查找元素在[0,n - 1]范围内，可以写成[0,n)，令r &#x3D; n，这时候只有两个元素时，r是取最右边元素的后一个位置的，l和r相差2，还会执行循环。<br>现在再来理解上一段的r1 &#x3D; mid，说明a[mid] &gt; x时，r &#x3D; mid就表示待查找元素会是在r的左边，因为r是开区间。上面这种写法修改了循环条件使得二分不会死循环，修改了区间的开闭性使得不会查找错误。另一种解决办法就是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line"> &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt;= x) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>不修改循环终止条件，想办法解决死循环的问题，首先想下为什么查找不小于x的第一个位置不会死循环？因为这时就算只有两个元素，l + 1 &#x3D; r,mid &#x3D; l,a[mid]小于x时l是会+1的，不小于x时r &#x3D; mid也会缩小区间。<br>而查找不大于x的最后一个位置之所以会死循环是因为编程语言里面除以2的下取整性，试想下如果l + 1 &#x3D; r时，mid &#x3D; （l + r） &#x2F; 2 &#x3D; l，一旦a[mid] &lt;&#x3D; x,l &#x3D; mid &#x3D; l，区间并没有缩小，从而陷入死循环；如果一开始取mid为r，一旦a[mid] &lt;&#x3D; x,l &#x3D; mid &#x3D; r,区间缩小，否则r &#x3D; mid - 1 &#x3D; l区间缩小，l都会与r相遇，就不会陷入死循环了。<br>如何做到上取整呢？只需要取mid时在l + r后面再加1即可，这里l和r都是闭区间，所以当a[mid] &gt; x时，r &#x3D; mid - 1.<br>是否还有其他办法既不修改区间的开闭性和循环终止条件，又不用上取整呢？答案是肯定的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> l1 = l, r1 = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l1 &lt; r1) &#123;</span><br><span class="line">    <span class="type">int</span> mid = l1 + r1 &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &lt;= x)  l1 = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>    r1 = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, l, l1 - (a[l1] == x ? <span class="number">0</span> : <span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>我们之所以会进行第二轮查找不大于x的最后一个位置，是因为第一轮已经找到了一个等于x的位置。所以完全可以当a[mid] &lt;&#x3D; x时，令l &#x3D; mid + 1，此时，l指向的元素可能是x也可能比x大，但是由于不论大小，l和r的指针都移动了，就不会陷入死循环了，最后，如果a[l] &#x3D;&#x3D; x则，l就是x出现的最后的位置，否则，l - 1就是x出现的最后一个位置。或许有人会疑惑，当a[mid] &lt;&#x3D; x时，l已经右移，最后l不是肯定指向的是大于x的位置嘛，为什么也可能指向等于x的位置？这是因为一旦第一轮查找的x出现的位置就是x唯一出现的位置，当x出现在数组末尾时，l &#x3D;&#x3D; r，循环不会执行，此刻l指向的还是x，所以加上这个判断就可以解决该问题了。这也是二分程序可能遇见的第三种问题，当左右指针都移动时，待查找元素处在元素末尾会引起查找错误。总的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100005</span>;</span><br><span class="line"><span class="type">int</span> n, q, x, a[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[mid] &lt; x)  l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>    r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[l] != x) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1 -1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> l1 = l, r1 = n;</span><br><span class="line">        <span class="keyword">while</span> (l1 + <span class="number">1</span> &lt; r1) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l1 + r1 &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[mid] &lt;= x)  l1 = mid;</span><br><span class="line">            <span class="keyword">else</span>    r1 = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, l, l1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
