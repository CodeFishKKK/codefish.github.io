<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>函数的图像（中）</title>
      <link href="/2022/09/12/%E5%87%BD%E6%95%B0%E7%9A%84%E5%9B%BE%E5%83%8F%EF%BC%88%E4%B8%AD%EF%BC%89/"/>
      <url>/2022/09/12/%E5%87%BD%E6%95%B0%E7%9A%84%E5%9B%BE%E5%83%8F%EF%BC%88%E4%B8%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<ul><li><p>三角函数tip：</p><p><img src="https://laukun-1313741272.cos.ap-guangzhou.myqcloud.com/Blog/7D75B82FCDED707D17E05299B27E9889.png"></p><blockquote><p>带绝对值的函数优先考虑函数图像</p></blockquote></li><li><p>证明f(x)&#x3D;常数c</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.求导f‘(x)=0 </span><br><span class="line"></span><br><span class="line">2.f(x0)=c</span><br></pre></td></tr></table></figure></li></ul><p>tip:画图象先算两端点再判断增减</p><ul><li><p>取整函数 y&#x3D;[x], 不超过x的最大整数</p><p>定义域：R</p><p>值域：Z</p></li></ul><p><img src="https://laukun-1313741272.cos.ap-guangzhou.myqcloud.com/Blog/V(ENR56R@%7B%7DWPE($KMHAG~H.png"></p><ul><li><p>Tip:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Tip: X~n+1~ = sinX~n~ &lt; X~n~ (X~n~&gt;0)</span><br><span class="line">=&gt; &#123;X~n~&#125; 单调递减</span><br></pre></td></tr></table></figure><blockquote><p>由数列的函数表达式判断增减性方法:</p><ul><li>10个常见不等式</li><li>求导</li></ul></blockquote></li><li><p>Tip: 不等式敏感：e^x^ &gt;&#x3D; x + 1</p><p>敏感变量：e^x^，  x</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 高数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/09/11/hello-world/"/>
      <url>/2022/09/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>初试线段树</title>
      <link href="/2021/06/18/%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B4%E6%95%B0%E9%97%AE%E9%A2%98-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2021/06/18/%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B4%E6%95%B0%E9%97%AE%E9%A2%98-%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个长度为 N 的数列 A，以及 M 条指令，每条指令可能是以下两种之一：</p><ol><li><code>C l r d</code>，表示把 A[l],A[l+1],…,A[r]都加上 d。</li><li><code>Q l r</code>，表示询问数列中第 l∼r个数的和。</li></ol><p>对于每个询问，输出一个整数表示答案输入格式</p><p>第一行两个整数 N,M。</p><p>第二行 NN 个整数 A[i]。</p><p>接下来 M 行表示 M条指令，每条指令的格式如题目描述所示。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每个询问，输出一个整数表示答案。</p><p>每个答案占一行。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N,M≤$10^5$<br>|d|≤10000<br>|A[i]|≤ $10^9$ </p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">10 5</span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line">Q 4 4</span><br><span class="line">Q 1 10</span><br><span class="line">Q 2 4</span><br><span class="line">C 3 6 3</span><br><span class="line">Q 2 4</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">55</span><br><span class="line">9</span><br><span class="line">15</span><br></pre></td></tr></table></figure><hr><p>分析：</p><p>题目涉及区间修改和区间查询，分析数据范围不能暴力，符合线段树的用法；<br>一旦涉及区间修改线段树就要用到懒标记；</p><h2 id="问：什么是懒标记，有什么作用？"><a href="#问：什么是懒标记，有什么作用？" class="headerlink" title="问：什么是懒标记，有什么作用？"></a>问：什么是懒标记，有什么作用？</h2><blockquote><p>懒标记就是用来记录要要对某一区间进行的修改，tr[u].add就是u区间的懒标记，它标志着u区间的每一个点都要加上add，但是先不直接加上去，否则复杂度就会大大提高，就体现不出线段树的优势所在，要查询或者修改带有懒标记的点的儿子时，懒标记就会使用对用pushdown操作把要修改的操作分配下去</p></blockquote><h2 id="问：什么时候进行pushdown操作？为什么要进行pushdown操作？"><a href="#问：什么时候进行pushdown操作？为什么要进行pushdown操作？" class="headerlink" title="问：什么时候进行pushdown操作？为什么要进行pushdown操作？"></a>问：什么时候进行pushdown操作？为什么要进行pushdown操作？</h2><blockquote><p>带懒标记节点就像是父亲，add是爷爷发给孙子的压岁钱，当需要计算儿子压岁钱（查询到带懒标记的儿子时）或者又有新的一笔钱要给孙子时（修改操作），父亲就需要先把这笔钱分发给儿子才能进行下一步操作<br>查询的到下面儿子的时候需要算上本属于儿子的懒标记的值，所以query时需要进行pushdown操作无容置疑<br>修改操作时懒标记时一个区间的操作，要改变就需要带着一个区间一块改变，如果一个新的修改执行pushdown没有执行，就是本来因该给儿子的还没有给。回溯时pushup操作就会拿着错误的值去计算父节点，导致结果出错！</p></blockquote><p>话不多说，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, w[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    LL sum, add;</span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;root = tr[u], &amp;left = tr[u &lt;&lt; <span class="number">1</span>], &amp;right = tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(root.add)&#123;</span><br><span class="line">        left.add += root.add, left.sum += (left.r - left.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        right.add += root.add, right.sum += (right.r - right.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        root.add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    tr[u].sum = (LL)tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) tr[u] = &#123;l, r, w[l], <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        tr[u] = &#123;l, r&#125;;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)&#123; </span><br><span class="line"><span class="comment">//区间修改如果找到完全在要修改的区间内的子区间，就直接加到懒标记上面，就代表着这个区间的每一个值都要这样修改</span></span><br><span class="line">         tr[u].sum += (LL)(tr[u].r - tr[u].l + <span class="number">1</span>) * v;</span><br><span class="line">         tr[u].add += (LL)v;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="built_in">pushdown</span>(u); <span class="comment">//此处分裂，修改到了可能带懒标记的儿子，要进行pushdown操作</span></span><br><span class="line">         <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, v);</span><br><span class="line">         <span class="keyword">if</span>(r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, v);</span><br><span class="line">         <span class="built_in">pushup</span>(u); <span class="comment">//回溯用修改后的儿子更新父亲的区间和</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u);  <span class="comment">//查询到了可能带懒标记的父亲的儿子</span></span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        LL sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= mid) sum = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; mid) sum += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;w[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    LL d;</span><br><span class="line">    <span class="keyword">while</span>(m -- )&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, &amp;op, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">if</span>(*op == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, l, r));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;d);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, l, r, d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP字符串</title>
      <link href="/2021/05/18/KMP%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2021/05/18/KMP%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是KMP算法及一些基本概念"><a href="#一、什么是KMP算法及一些基本概念" class="headerlink" title="一、什么是KMP算法及一些基本概念"></a>一、什么是KMP算法及一些基本概念</h2><p>首先，什么是KMP算法。这是一个字符串匹配算法，对暴力的那种一一比对的方法进行了优化，使时间复杂度大大降低（我不会算时间复杂度。。。，目前也只能这么理解，还有KMP是取的三个发明人的名字首字母组成的名字）。</p><p> 然后是一些基本概念：</p><blockquote><p>1、s[ ]是模式串，即比较长的字符串。<br>2、p[ ]是模板串，即比较短的字符串。（这样可能不严谨。。。）<br>3、“非平凡前缀”：指除了最后一个字符以外，一个字符串的全部头部组合。<br>4、“非平凡后缀”：指除了第一个字符以外，一个字符串的全部尾部组合。（后面会有例子，均简称为前&#x2F;后缀）<br>5、“部分匹配值”：前缀和后缀的最长共有元素的长度。<br>6、next[ ]是“部分匹配值表”，即next数组，它存储的是每一个下标对应的“部分匹配值”，是KMP算法的核心。（后面作详细讲解）。</p></blockquote><p>核心思想 ： 在每次失配时，不是把p串往后移一位，而是把p串往后移动至下一次可以和前面部分匹配的位置，这样就可以跳过大多数的失配步骤。而每次p串移动的步数就是通过查找next[ ]数组确定的。</p><h3 id="二、next数组的含义及手动模拟（具体求法和代码在后面）"><a href="#二、next数组的含义及手动模拟（具体求法和代码在后面）" class="headerlink" title="二、next数组的含义及手动模拟（具体求法和代码在后面）"></a>二、next数组的含义及手动模拟（具体求法和代码在后面）</h3><p> 然后来说明一下next数组的含义：对next[ j ] ，是p[ 1, j ]串中前缀和后缀相同的最大长度（部分匹配值），即 p[ 1, next[ j ] ] &#x3D; p[ j - next[ j ] + 1, j ]。</p><p><img src="https://cdn.acwing.com/media/article/image/2020/06/12/31041_6f934f82ac-next%E4%BE%8B%E5%AD%90.PNG"></p><hr><p>手动模拟求next数组：</p><p>对 p &#x3D; “abcab”</p><p><img src="https://laukun-1313741272.cos.ap-guangzhou.myqcloud.com/Blog/kmp.png"></p><p>对next[ 1 ] ：前缀 &#x3D; 空集—————后缀 &#x3D; 空集—————next[ 1 ] &#x3D; 0;</p><p>对next[ 2 ] ：前缀 &#x3D; { a }—————后缀 &#x3D; { b }—————next[ 2 ] &#x3D; 0;</p><p>对next[ 3 ] ：前缀 &#x3D; { a , ab }—————后缀 &#x3D; { c , bc}—————next[ 3 ] &#x3D; 0;</p><p>对next[ 4 ] ：前缀 &#x3D; { a , ab , abc }—————后缀 &#x3D; { a . ca , bca }—————next[ 4 ] &#x3D; 1;</p><p>对next[ 5 ] ：前缀 &#x3D; { a , ab , abc , abca }————后缀 &#x3D; { b , ab , cab , bcab}————next[ 5 ] &#x3D; 2;</p><hr><h3 id="三、匹配思路和实现代码"><a href="#三、匹配思路和实现代码" class="headerlink" title="三、匹配思路和实现代码"></a>三、匹配思路和实现代码</h3><p>KMP主要分两步：求next数组、匹配字符串。个人觉得匹配操作容易懂一些，疑惑我一整天的是求next数组的思想。所以先把匹配字符串讲一下。</p><p> s串 和 p串都是从1开始的。i 从1开始，j 从0开始，每次s[ i ] 和p[ j + 1 ]比较</p><p>其中1串为[ 1, next[ j ] ]，3串为[ j - next[ j ] + 1 , j ]。由匹配可知 1串等于3串，3串等于2串。所以直接移动p串使1到3的位置即可。这个操作可由j &#x3D; next[ j ]直接完成。 如此往复下去，当 j &#x3D;&#x3D; m时匹配成功。</p><hr><h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j &amp;&amp; s[i] != p[j+<span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="comment">//如果j有对应p串的元素， 且s[i] != p[j+1], 则失配， 移动p串</span></span><br><span class="line">    <span class="comment">//用while是由于移动后可能仍然失配，所以要继续移动直到匹配或整个p串移到后面（j = 0)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s[i] == p[j+<span class="number">1</span>]) j++;</span><br><span class="line">    <span class="comment">//当前元素匹配，j移向p串下一位</span></span><br><span class="line">    <span class="keyword">if</span>(j == m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//匹配成功，进行相关操作</span></span><br><span class="line">        j = next[j];  <span class="comment">//继续匹配下一个子串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、求next数组的思路和实现代码"><a href="#四、求next数组的思路和实现代码" class="headerlink" title="四、求next数组的思路和实现代码"></a>四、求next数组的思路和实现代码</h3><p>next数组的求法是通过模板串自己与自己进行匹配操作得出来的（代码和匹配操作几乎一样）。</p><h3 id="代码如下：-1"><a href="#代码如下：-1" class="headerlink" title="代码如下："></a>代码如下：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j &amp;&amp; p[i] != p[j+<span class="number">1</span>]) j = next[j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p[i] == p[j+<span class="number">1</span>]) j++;</span><br><span class="line"></span><br><span class="line">    next[i] = j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码和匹配操作的代码几乎一样，关键在于每次移动 i 前，将 i 前面已经匹配的长度记录到next数组中。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">10010</span>; <span class="comment">//N为模式串长度，M匹配串长度</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> ne[M]; <span class="comment">//next[]数组，避免和头文件next冲突</span></span><br><span class="line"><span class="type">char</span> s[N], p[M];  <span class="comment">//s为模式串， p为匹配串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s+<span class="number">1</span> &gt;&gt; m &gt;&gt; p+<span class="number">1</span>;  <span class="comment">//下标从1开始</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//求next[]数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; p[i] != p[j+<span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(p[i] == p[j+<span class="number">1</span>]) j++;</span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//匹配操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; s[i] != p[j+<span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(s[i] == p[j+<span class="number">1</span>]) j++;</span><br><span class="line">        <span class="keyword">if</span>(j == m)  <span class="comment">//满足匹配条件，打印开头下标, 从0开始</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//匹配完成后的具体操作</span></span><br><span class="line">            <span class="comment">//如：输出以0开始的匹配子串的首字母下标</span></span><br><span class="line">            <span class="comment">//printf(&quot;%d &quot;, i - m); (若从1开始，加1)</span></span><br><span class="line">            j = ne[j];            <span class="comment">//再次继续匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>万能神器-二分法</title>
      <link href="/2021/05/12/%E4%BA%8C%E5%88%86/"/>
      <url>/2021/05/12/%E4%BA%8C%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h3 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h3><p>给定一个按照升序排列的长度为n的整数数组，以及 q 个查询。<br>对于每个查询，返回一个元素k的起始位置和终止位置（位置从0开始计数）。<br>如果数组中不存在该元素，则返回“-1 -1”。<br>输入格式<br>第一行包含整数n和q，表示数组长度和询问个数。<br>第二行包含n个整数（均在1~10000范围内），表示完整数组。<br>接下来q行，每行包含一个整数k，表示一个询问元素。<br>输出格式<br>共q行，每行包含两个整数，表示所求元素的起始位置和终止位置。<br>如果数组中不存在该元素，则返回“-1 -1”。<br>数据范围<br>1≤n≤100000<br>1≤n≤100000</p><p>1≤q≤10000<br>1≤q≤10000</p><p>1≤k≤10000<br>1≤k≤10000</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入样例：</span><br><span class="line">6 3</span><br><span class="line">1 2 2 3 3 4</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">输出样例：</span><br><span class="line">3 4</span><br><span class="line">5 5</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure><hr><p>分析：</p><p>本题是练习二分很好的一道题目，二分程序虽然简单，但是如果写之前不考虑好想要查找的是什么，十有八九会是死循环或者查找错误，就算侥幸写对了也只是运气好而已。用二分去查找元素要求数组的有序性或者拥有类似于有序的性质，对本题而言，一个包含重复元素的有序序列，要求输出某元素出现的起始位置和终止位置，翻译一下就是：在数组中查找某元素，找不到就输出-1，找到了就输出不小于该元素的最小位置和不大于该元素的最大位置。所以，需要写两个二分，一个需要找到&gt;&#x3D;x的第一个数，另一个需要找到&lt;&#x3D;x的最后一个数。查找不小于x的第一个位置，较为简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &lt; x)  l = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>    r = mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当a[mid]小于x时，令l &#x3D; mid + 1，mid及其左边的位置被排除了，可能出现解的位置是mid + 1及其后面的位置；当a[mid] &gt;&#x3D; x时，说明mid及其左边可能含有值为x的元素；当查找结束时，l与r相遇，l所在元素若是x则一定是x出现最小位置，因为l左边的元素必然都小于x。查找不大于x的最后一个位置，便不容易了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> l1 = l, r1 = n;</span><br><span class="line"><span class="keyword">while</span> (l1 + <span class="number">1</span> &lt; r1) &#123;</span><br><span class="line">    <span class="type">int</span> mid = l1 + r1 &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &lt;= x)  l1 = mid;</span><br><span class="line">    <span class="keyword">else</span>    r1 = mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要查找不大于x的最后一个位置，当a[mid] &lt;&#x3D; x时，待查找元素只可能在mid及其后面，所以l &#x3D; mid；当a[mid] &gt; x时，待查找元素只会在mid左边，令r &#x3D; mid。<br>为什么不令r &#x3D; mid - 1呢？因为如果按照上一个二分的写法，循环判断条件还是l &lt; r,当只有两个元素比如2 2时，l指向第一个元素，r指向第二个元素，mid指向第一个元素，a[mid] &lt;&#x3D; x，l &#x3D; mid还是指向第一个元素，指针不移动了，陷入死循环了，此刻l + 1 &#x3D;&#x3D; r，未能退出循环。<br>那么直接把循环判断条件改成l + 1 &lt; r呢？此时一旦只有两个元素，l和r差1，循环便不再执行，查找错误。<br>所以这里出现了二分的典型错误，l &#x3D;&#x3D; r作为循环终止条件，会出现死循环，l + 1 &#x3D;&#x3D; r作为循环终止条件，会出现查找错误。<br>问题如何解决，一种方法就是将查找的区间设置为左闭右开，比如待查找元素在[0,n - 1]范围内，可以写成[0,n)，令r &#x3D; n，这时候只有两个元素时，r是取最右边元素的后一个位置的，l和r相差2，还会执行循环。<br>现在再来理解上一段的r1 &#x3D; mid，说明a[mid] &gt; x时，r &#x3D; mid就表示待查找元素会是在r的左边，因为r是开区间。上面这种写法修改了循环条件使得二分不会死循环，修改了区间的开闭性使得不会查找错误。另一种解决办法就是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line"> &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt;= x) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>不修改循环终止条件，想办法解决死循环的问题，首先想下为什么查找不小于x的第一个位置不会死循环？因为这时就算只有两个元素，l + 1 &#x3D; r,mid &#x3D; l,a[mid]小于x时l是会+1的，不小于x时r &#x3D; mid也会缩小区间。<br>而查找不大于x的最后一个位置之所以会死循环是因为编程语言里面除以2的下取整性，试想下如果l + 1 &#x3D; r时，mid &#x3D; （l + r） &#x2F; 2 &#x3D; l，一旦a[mid] &lt;&#x3D; x,l &#x3D; mid &#x3D; l，区间并没有缩小，从而陷入死循环；如果一开始取mid为r，一旦a[mid] &lt;&#x3D; x,l &#x3D; mid &#x3D; r,区间缩小，否则r &#x3D; mid - 1 &#x3D; l区间缩小，l都会与r相遇，就不会陷入死循环了。<br>如何做到上取整呢？只需要取mid时在l + r后面再加1即可，这里l和r都是闭区间，所以当a[mid] &gt; x时，r &#x3D; mid - 1.<br>是否还有其他办法既不修改区间的开闭性和循环终止条件，又不用上取整呢？答案是肯定的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> l1 = l, r1 = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l1 &lt; r1) &#123;</span><br><span class="line">    <span class="type">int</span> mid = l1 + r1 &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &lt;= x)  l1 = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>    r1 = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, l, l1 - (a[l1] == x ? <span class="number">0</span> : <span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>我们之所以会进行第二轮查找不大于x的最后一个位置，是因为第一轮已经找到了一个等于x的位置。所以完全可以当a[mid] &lt;&#x3D; x时，令l &#x3D; mid + 1，此时，l指向的元素可能是x也可能比x大，但是由于不论大小，l和r的指针都移动了，就不会陷入死循环了，最后，如果a[l] &#x3D;&#x3D; x则，l就是x出现的最后的位置，否则，l - 1就是x出现的最后一个位置。或许有人会疑惑，当a[mid] &lt;&#x3D; x时，l已经右移，最后l不是肯定指向的是大于x的位置嘛，为什么也可能指向等于x的位置？这是因为一旦第一轮查找的x出现的位置就是x唯一出现的位置，当x出现在数组末尾时，l &#x3D;&#x3D; r，循环不会执行，此刻l指向的还是x，所以加上这个判断就可以解决该问题了。这也是二分程序可能遇见的第三种问题，当左右指针都移动时，待查找元素处在元素末尾会引起查找错误。总的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100005</span>;</span><br><span class="line"><span class="type">int</span> n, q, x, a[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[mid] &lt; x)  l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>    r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[l] != x) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1 -1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> l1 = l, r1 = n;</span><br><span class="line">        <span class="keyword">while</span> (l1 + <span class="number">1</span> &lt; r1) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l1 + r1 &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[mid] &lt;= x)  l1 = mid;</span><br><span class="line">            <span class="keyword">else</span>    r1 = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, l, l1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
